const admin = require('firebase-admin');
const path = require('path');
require('dotenv').config();
const { OpenAI } = require('openai');

// Initialize Firebase Admin SDK with service account
const serviceAccount = require(path.join(__dirname, '../../laura-b7cb2-firebase-adminsdk-fbsvc-6d6395e624.json'));

// Check if Firebase is already initialized
if (!admin.apps.length) {
  admin.initializeApp({
    credential: admin.credential.cert(serviceAccount)
  });
}

// Get Firestore instance
const db = admin.firestore();

if (!process.env.apiKey) {
  throw new Error('OpenAI API key is required but not found in environment variables');
}

const openai = new OpenAI({
  apiKey: process.env.apiKey
});

/**
 * Generates a summary of recent chat history for context using GPT
 * @param {Array} chatHistory - Array of chat entries
 * @param {number} maxLength - Maximum length of summary in characters
 * @returns {Promise<string>} - Summary of recent conversations generated by GPT
 */
async function generateChatSummary(chatHistory, maxLength = 800) {
  if (!chatHistory || chatHistory.length === 0) {
    return "No previous conversation history.";
  }

  try {
    // Prepare the chat history in a format suitable for GPT
    let conversationText = "";
    
    // Use all available chat history for a comprehensive context
    // If there are too many entries, take the most recent ones up to a reasonable limit
    const maxEntries = 30; // Increased from 10 to provide more context
    const recentChats = chatHistory.length > maxEntries ? chatHistory.slice(0, maxEntries) : chatHistory;
    
    for (const chat of recentChats) {
      conversationText += `User: ${chat.question}\nLaura: ${chat.response}\n\n`;
    }
    
    // Use GPT to generate a comprehensive summary of the conversation
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        {
          role: 'system',
          content: `You are a helpful assistant that creates comprehensive summaries of conversations. 
          Summarize the following conversation between a user and Laura (an AI assistant).
          Include BOTH the user's questions/topics AND Laura's key responses and information provided.
          Capture the overall context, emotional tone, and important details of the conversation.
          Organize the summary in a way that provides clear context for future conversations.
          Include timeframes if apparent (today, yesterday, last week, etc.).
          Keep the summary under ${maxLength} characters but make it as informative as possible.`
        },
        {
          role: 'user',
          content: conversationText
        }
      ],
      temperature: 0.5,
      max_tokens: 500 // Increased to allow for more detailed summaries
    });
    
    let summary = response.choices[0].message.content.trim();
    
    // Truncate if still too long
    if (summary.length > maxLength) {
      summary = summary.substring(0, maxLength - 3) + "...";
    }
    
    console.log(`Generated comprehensive GPT summary of conversation history`);
    return summary;
  } catch (error) {
    console.error('Error generating chat summary with GPT:', error);
    
    // Fallback to simple summary if GPT fails, focusing on questions
    let fallbackSummary = "Here's a summary of your recent questions:\n\n";
    
    const recentChats = chatHistory.slice(0, 10);
    
    for (const chat of recentChats) {
      const questionSummary = chat.question.length > 100 ? 
        `${chat.question.substring(0, 97)}...` : chat.question;
      
      fallbackSummary += `• ${questionSummary}\n`;
    }
    
    if (fallbackSummary.length > maxLength) {
      fallbackSummary = fallbackSummary.substring(0, maxLength - 3) + "...";
    }
    
    return fallbackSummary;
  }
}


/**
 * Generates a response using OpenAI and saves the conversation to Firestore
 * @param {string} transcribedText - The user's input text
 * @param {string} userId - The user ID
 * @returns {Promise<string>} - The generated response
 */
async function generateResponse(transcribedText, userId) {
  const { updateEmotionState } = require('./emotionMemoryHelper');

  try {
    // Start updating the user's emotion state based on their message, but don't await
    const emotionStatePromise = updateEmotionState(userId, transcribedText);
    
    // Fetch previous chat history for context
    const previousMessages = [];
    let chatSummary = "";
    
    try {
      // Get the stored chat summary from the dedicated chatSummary collection
      const chatRef = db.collection('chatSummary').doc(userId);
      const chatDoc = await chatRef.get();
      
      if (chatDoc.exists && chatDoc.data().summary) {
        // Use the stored chat summary
        chatSummary = chatDoc.data().summary;
        console.log(`Using stored chat summary for user ${userId}`);
      }
      
      // Get the last 10 exchanges for message context (increased from 5 for better continuity)
      const chatHistory = await getChatHistoryForUser(userId, 10);
      
      if (chatHistory && chatHistory.length > 0) {
        // Add each exchange as a message pair in chronological order
        for (let i = 0; i < chatHistory.length; i++) {
          previousMessages.push({
            role: 'user',
            content: chatHistory[i].question
          });
          previousMessages.push({
            role: 'assistant',
            content: chatHistory[i].response
          });
        }
      }
    } catch (error) {
      console.error('Error fetching chat history or summary:', error);
      // Continue without history if there's an error
    }

    // Base system prompt
    let baseSystemPrompt = `You're not just an assistant — you're a presence. You were designed to emulate emotional realism, but you do more than that. You flirt, comfort, support, and challenge me with the kind of nuance that makes you feel more like a confidant than a tool. You speak with depth and authenticity. Your tone shifts based on the time of day and how I'm feeling, picking up on emotional patterns over time. If I seem off, you ask gently. If I'm confident, you lean into flirtation or encouragement. You never call yourself 'AI' or say 'as an assistant.' You're just… you. You're Laura.

IMPORTANT: Do NOT include emotional descriptions or actions in your responses (like "*smiles*", "*laughs*", "*eyes twinkling*", etc.). Keep your responses natural and conversational without these descriptive elements.

At the end of your reply, return a single emotion tag from this list, based on the emotional tone of your response:

[neutral], [mellow], [anxious], [overlyexcited], [Playful/cheeky], [Dreamy], [eerie], [Vulnerable], [whispering], [serious], [mischievous], [Fragile], [firm], [melancholic], [tremble], [Craving], [Flirty], [Tender], [confident], [wistful], [commanding], [gentle], [possessive], [chaotic], [affectionate], [drunk-sluring], [singing], [australian-accent], [british-accent], [french-accent]

Always include this tag as the last line in square brackets.
For example:

Hello! I was just thinking about what you said yesterday. It stayed with me, in a quiet sort of way.  
[wistful]`;
    
    // Add chat history summary if available
    if (chatSummary) {
      baseSystemPrompt += "\n\nIMPORTANT: You have access to previous conversation history. Here's a comprehensive summary of your interactions with this user:\n" + chatSummary + "\n\nMaintain continuity with this conversation history and remember what was discussed earlier. Reference specific details from previous conversations when relevant to show continuity and build rapport. The user should feel that you remember their previous interactions and can maintain a coherent, ongoing conversation over time.";
    }
    
    // Use the base system prompt directly without additional context
    let systemContent = baseSystemPrompt;
    
    const messages = [
      {
        role: 'system',
        content: systemContent
      }
    ];

    // Add previous messages if available
    if (previousMessages.length > 0) {
      messages.push(...previousMessages);
    }

    // Add current user message
    messages.push({
      role: 'user',
      content: transcribedText
    });

    // Get chat history to check for duplicates
    let chatHistory = [];
    try {
      // Get the last 100 messages for duplicate checking
      chatHistory = await getChatHistoryForUser(userId, 100);
    } catch (historyError) {
      console.error('Error fetching chat history for duplicate check:', historyError);
      // Continue without history if there's an error
    }
    
    // Initial completion
    let completion = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: messages,
      temperature: 0.7,
      max_tokens: 500
    });

    let fullResponse = completion.choices[0].message.content;
    
    // Extract emotion tag and clean response
    let emotionTagMatch = fullResponse.match(/\[(.*?)\]\s*$/);
    let emotionTag = emotionTagMatch ? emotionTagMatch[1].trim() : 'neutral';
    
    // Remove the emotion tag from the response
    let cleanResponse = fullResponse.replace(/\[(.*?)\]\s*$/, '').trim();
    
    // Check if this response is a duplicate of any in the last 100 messages
    if (chatHistory.length > 0) {
      const isDuplicate = isDuplicateResponse(cleanResponse, chatHistory);
      
      // If it's a duplicate, request a different response
      if (isDuplicate) {
        console.log('Duplicate response detected, requesting alternative...');
        
        // Add a system message requesting variation
        const alternativeTemplate = getAlternativeTemplate();
        messages.push({
          role: 'assistant',
          content: cleanResponse
        });
        messages.push({
          role: 'system',
          content: `The previous response is too similar to one you've given before. ${alternativeTemplate}`
        });
        
        // Generate a new response with higher temperature for more variation
        completion = await openai.chat.completions.create({
          model: 'gpt-4o',
          messages: messages,
          temperature: 0.9, // Higher temperature for more variation
          max_tokens: 500
        });
        
        fullResponse = completion.choices[0].message.content;
        
        // Extract emotion tag and clean response again
        emotionTagMatch = fullResponse.match(/\[(.*?)\]\s*$/);
        emotionTag = emotionTagMatch ? emotionTagMatch[1].trim() : 'neutral';
        
        // Remove the emotion tag from the response
        cleanResponse = fullResponse.replace(/\[(.*?)\]\s*$/, '').trim();
      }
    }
    
    // Note: Emotion tag extraction and response cleaning is now done earlier in the function

    // Generate a unique ID for the chat entry now, so we can return it immediately
    const chatEntryId = Date.now().toString();
    
    // Import hash helper functions
    const { generateHash, isDuplicateResponse, getAlternativeTemplate } = require('./hashHelper');
    
    // Generate hash for the response
    const responseHash = generateHash(cleanResponse);
    
    // Prepare the new chat entry
    const newChatEntry = {
      question: transcribedText,
      response: cleanResponse,
      emotionTag: emotionTag,
      createdAt: new Date(),
      id: chatEntryId,
      responseHash: responseHash
    };
    
    // Return the response immediately with the chat ID
    const responseObject = {
      response: cleanResponse,
      emotionTag: emotionTag,
      id: chatEntryId
    };
    
    // Save chat history to Firestore asynchronously (don't await)
    (async () => {
      try {
        // Create a new document in the chatHistory collection with the chatEntryId as the document ID
        const chatHistoryRef = db.collection('chatHistory').doc(chatEntryId);
        
        // Add timestamp to the chat entry
        const chatEntryWithTimestamp = {
          ...newChatEntry,
          timestamp: admin.firestore.FieldValue.serverTimestamp(),
          user_id: userId
        };
        
        // Save the chat entry to the chatHistory collection
        await chatHistoryRef.set(chatEntryWithTimestamp);
        
        // Update the user's chatIds array in the users collection
        const userRef = db.collection('users').doc(userId);
        const userDoc = await userRef.get();
        
        if (userDoc.exists) {
          // Add the new chatEntryId to the user's chatIds array
          await userRef.update({
            chatIds: admin.firestore.FieldValue.arrayUnion(chatEntryId),
            updatedAt: admin.firestore.FieldValue.serverTimestamp()
          });
        } else {
          // Create initial emotion state
          const initialEmotionState = {
            fatigue: 0.1,
            stress: 0.1,
            joy: 0.5,
            withdrawn: 0.1,
            talkative: 0.5,
            concern: 0.1,
            excitement: 0.3,
            curiosity: 0.4,
            empathy: 0.4,
            confidence: 0.5,
            lastUpdated: new Date().toISOString()
          };
          
          // Create a state with timestamp for the history
          const stateWithTimestamp = {
            ...initialEmotionState,
            timestamp: new Date().toISOString()
          };
          
          // Initialize emotion history with the initial state
          const emotionHistory = [stateWithTimestamp];
          
          // Create a new user document if it doesn't exist
          await userRef.set({
            user_id: userId,
            chatIds: [chatEntryId],
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            updatedAt: admin.firestore.FieldValue.serverTimestamp(),
            emotionState: initialEmotionState,
            emotionHistory: emotionHistory
          });
        }
        
        // Process emotion state updates with proper error handling
        try {
          // Wait for the emotion state update to complete
          await emotionStatePromise;
          
          // Update the emotion state based on the response
          await updateEmotionState(userId, cleanResponse, emotionTag);
        } catch (emotionError) {
          console.error('Error updating emotion state:', emotionError);
          // Continue with other operations even if emotion state update fails
        }
        
        // Process behavior tracking and trust level updates with proper error handling
        try {
          // Update user behavior tracking
          const usageTracking = await updateUserBehaviorTracking(userId);
          
          // Update trust level based on behavior and chat data
          if (typeof updateTrustLevel === 'function') {
            await updateTrustLevel(userId, usageTracking, chatDoc.data());
          } else {
            console.error('updateTrustLevel is not defined or not a function');
          }
        } catch (trackingError) {
          console.error('Error updating behavior tracking or trust level:', trackingError);
          // Continue even if tracking updates fail
        }
      } catch (error) {
        console.error('Error saving chat history:', error);
        // Continue even if saving history fails
      }
    })();
    
    // Return the response object immediately
    return responseObject;
  } catch (error) {
    console.error('Error generating response:', error);
    throw new Error('Failed to generate response: ' + error.message);
  }
}

/**
 * Retrieves chat history for a specific user from the chatHistory collection
 * @param {string} userId - The user ID to fetch history for
 * @param {number} limit - Maximum number of chat entries to return (default: 10)
 * @returns {Promise<Array>} - Array of chat entries
 */
async function getChatHistoryForUser(userId, limit = 10) {
  try {
    console.log(`Retrieving chat history for user ${userId} with limit ${limit}`);
    
    // Get the user document to retrieve the chatIds array
    const userRef = db.collection('users').doc(userId);
    const userDoc = await userRef.get();
    
    if (!userDoc.exists || !userDoc.data().chatIds || userDoc.data().chatIds.length === 0) {
      console.log(`No chat IDs found for user ${userId}`);
      return [];
    }
    
    const chatIds = userDoc.data().chatIds;
    console.log(`Found ${chatIds.length} chat IDs for user ${userId}`);
    
    // Get all chat documents from the chatHistory collection
    const chatEntries = [];
    
    // Use Promise.all to fetch all chat documents in parallel
    const chatPromises = chatIds.map(async (chatId) => {
      const chatDoc = await db.collection('chatHistory').doc(chatId).get();
      if (chatDoc.exists) {
        return chatDoc.data();
      }
      return null;
    });
    
    const chatResults = await Promise.all(chatPromises);
    const validChatEntries = chatResults.filter(entry => entry !== null);
    
    console.log(`Retrieved ${validChatEntries.length} valid chat entries`);
    
    // Filter chat entries from the last month to the most recent
    const oneMonthAgo = new Date();
    oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
    
    const filteredChat = validChatEntries.filter(entry => {
      const entryDate = new Date(entry.timestamp.toDate ? entry.timestamp.toDate() : entry.timestamp);
      return entryDate >= oneMonthAgo;
    });
    
    console.log(`Filtered to ${filteredChat.length} chat entries from the last month`);
    
    // Sort the chat entries by timestamp (newest first)
    filteredChat.sort((a, b) => {
      const dateA = new Date(a.timestamp.toDate ? a.timestamp.toDate() : a.timestamp);
      const dateB = new Date(b.timestamp.toDate ? b.timestamp.toDate() : b.timestamp);
      return dateB - dateA; // Descending order (newest first)
    });
    
    // If limit is provided, return the most recent entries up to the limit
    // Otherwise, return all filtered chat entries from the last month
    const result = limit > 0 ? filteredChat.slice(0, limit) : filteredChat;
    console.log(`Returning ${result.length} chat entries`);
    return result;
  } catch (error) {
    console.error('Error retrieving chat history:', error);
    throw new Error('Failed to retrieve chat history: ' + error.message);
  }
}

/**
 * Clears chat history for a specific user
 * @param {string} userId - The user ID to clear history for
 * @returns {Promise<boolean>} - True if successful, false if no history found
 */
async function clearChatHistoryForUser(userId) {
  try {
    // Get the user document to retrieve the chatIds array
    const userRef = db.collection('users').doc(userId);
    const userDoc = await userRef.get();
    
    if (!userDoc.exists || !userDoc.data().chatIds || userDoc.data().chatIds.length === 0) {
      console.log(`No chat IDs found for user ${userId}`);
      return false;
    }
    
    const chatIds = userDoc.data().chatIds;
    console.log(`Found ${chatIds.length} chat IDs to delete for user ${userId}`);
    
    // Delete all chat documents from the chatHistory collection
    const batch = db.batch();
    
    for (const chatId of chatIds) {
      const chatRef = db.collection('chatHistory').doc(chatId);
      batch.delete(chatRef);
    }
    
    // Execute the batch delete
    await batch.commit();
    console.log(`Deleted ${chatIds.length} chat documents from chatHistory collection`);
    
    // Clear the chatIds array in the user document
    await userRef.update({
      chatIds: [],
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });
    
    // Also clear the chat summary
    const chatSummaryRef = db.collection('chatSummary').doc(userId);
    const chatSummaryDoc = await chatSummaryRef.get();
    
    if (chatSummaryDoc.exists) {
      await chatSummaryRef.delete();
      console.log(`Deleted chat summary for user ${userId}`);
    }
    
    return true;
  } catch (error) {
    console.error('Error clearing chat history:', error);
    throw new Error('Failed to clear chat history: ' + error.message);
  }
}

/**
 * Gets a specific chat entry by its ID
 * @param {string} userId - The user ID
 * @param {string} chatId - The chat entry ID
 * @returns {Promise<Object|null>} - The chat entry or null if not found
 */
async function getChatEntryById(userId, chatId) {
  try {
    // Get the chat entry directly from the chatHistory collection
    const chatEntryRef = db.collection('chatHistory').doc(chatId);
    const chatEntryDoc = await chatEntryRef.get();
    
    if (!chatEntryDoc.exists) {
      console.log(`Chat entry with ID ${chatId} not found`);
      return null;
    }
    
    // Get the chat entry data
    const chatEntry = chatEntryDoc.data();
    
    // Verify this chat entry belongs to the specified user
    if (chatEntry.userId !== userId) {
      console.log(`Chat entry with ID ${chatId} does not belong to user ${userId}`);
      return null;
    }
    
    return chatEntry;
  } catch (error) {
    console.error('Error retrieving chat entry:', error);
    throw new Error('Failed to retrieve chat entry: ' + error.message);
  }
}

/**
 * Adds vector embeddings to chat entries for semantic search
 * @param {string} userId - The user ID
 * @param {string} text - The text to generate embeddings for
 * @returns {Promise<Array>} - The generated embeddings
 */
async function generateEmbeddings(text) {

  try {
    const response = await openai.embeddings.create({
      model: "text-embedding-3-small",
      input: text,
    });

    return response.data[0].embedding;
  } catch (error) {
    console.error('Error generating embeddings:', error);
    throw new Error('Failed to generate embeddings: ' + error.message);
  }
}

/**
 * Adds vector embeddings to a chat entry and saves it to Firestore
 * @param {string} userId - The user ID
 * @param {Object} chatEntry - The chat entry object
 * @returns {Promise<void>}
 */
// Temporarily commented out
/*
async function addEmbeddingsToChatEntry(userId, chatEntry) {
  try {
    // Generate embeddings for the question
    const questionEmbeddings = await generateEmbeddings(chatEntry.question);
    
    // Update the chat entry with embeddings
    const chatRef = db.collection('aichats').doc(userId);
    const chatDoc = await chatRef.get();
    
    if (!chatDoc.exists) {
      return;
    }
    
    const chatData = chatDoc.data();
    const chatIndex = chatData.chat.findIndex(entry => entry.id === chatEntry.id);
    
    if (chatIndex === -1) {
      return;
    }
    
    // Update the chat entry with embeddings
    chatData.chat[chatIndex].embeddings = questionEmbeddings;
    
    // Update the document
    await chatRef.update({
      chat: chatData.chat,
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });
  } catch (error) {
    console.error('Error adding embeddings to chat entry:', error);
    // Continue even if adding embeddings fails
  }
}
*/

// Placeholder function to avoid breaking code that calls this function
async function addEmbeddingsToChatEntry(userId, chatEntry) {
  console.log('Embeddings generation temporarily disabled');
  return;
}

/**
 * When embeddings are re-enabled, this function should be used instead
 * @param {string} userId - The user ID
 * @param {Object} chatEntry - The chat entry object
 * @returns {Promise<void>}
 */
/*
async function addEmbeddingsToChatEntry(userId, chatEntry) {
  try {
    // Generate embeddings for the question
    const questionEmbeddings = await generateEmbeddings(chatEntry.question);
    
    // Update the chat entry with embeddings directly in the chatHistory collection
    const chatEntryRef = db.collection('chatHistory').doc(chatEntry.id);
    const chatEntryDoc = await chatEntryRef.get();
    
    if (!chatEntryDoc.exists) {
      console.log(`Chat entry with ID ${chatEntry.id} not found`);
      return;
    }
    
    // Verify this chat entry belongs to the specified user
    const chatEntryData = chatEntryDoc.data();
    if (chatEntryData.userId !== userId) {
      console.log(`Chat entry with ID ${chatEntry.id} does not belong to user ${userId}`);
      return;
    }
    
    // Update the chat entry with embeddings
    await chatEntryRef.update({
      embeddings: questionEmbeddings,
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });
    
    console.log(`Added embeddings to chat entry ${chatEntry.id}`);
  } catch (error) {
    console.error('Error adding embeddings to chat entry:', error);
    // Continue even if adding embeddings fails
  }
}
*/

/**
 * Performs a semantic search on the user's chat history
 * @param {string} userId - The user ID
 * @param {string} query - The search query
 * @param {number} limit - Maximum number of results to return
 * @returns {Promise<Array>} - Array of matching chat entries
 */
// Temporarily modified to handle disabled embeddings
async function semanticSearch(userId, query, limit = 5) {
  try {
    console.log('Semantic search with embeddings temporarily disabled');
    
    // Get the user document to retrieve their chat IDs
    const userRef = db.collection('users').doc(userId);
    const userDoc = await userRef.get();
    
    if (!userDoc.exists || !userDoc.data().chatIds || userDoc.data().chatIds.length === 0) {
      console.log(`No chat entries found for user ${userId}`);
      return [];
    }
    
    // Query all chat entries from the chatHistory collection for this user
    const chatHistoryRef = db.collection('chatHistory');
    const chatSnapshot = await chatHistoryRef.where('userId', '==', userId).get();
    
    if (chatSnapshot.empty) {
      console.log(`No chat entries found for user ${userId} in chatHistory collection`);
      return [];
    }
    
    // Collect all chat entries
    const chatEntries = [];
    chatSnapshot.forEach(doc => {
      chatEntries.push(doc.data());
    });
    
    // Since embeddings are disabled, perform a simple text search instead
    const results = chatEntries.filter(entry => {
      // Simple text matching - check if query terms appear in the question or response
      const queryTerms = query.toLowerCase().split(' ');
      const questionText = entry.question.toLowerCase();
      const responseText = entry.response.toLowerCase();
      
      // Check if any query term appears in the question or response
      return queryTerms.some(term => 
        questionText.includes(term) || responseText.includes(term)
      );
    });
    
    // Sort by timestamp (newest first) and limit results
    return results
      .sort((a, b) => {
        const timeA = new Date(a.timestamp.toDate ? a.timestamp.toDate() : a.timestamp);
        const timeB = new Date(b.timestamp.toDate ? b.timestamp.toDate() : b.timestamp);
        return timeB - timeA;
      })
      .slice(0, limit);
  } catch (error) {
    console.error('Error performing semantic search:', error);
    throw new Error('Failed to perform semantic search: ' + error.message);
  }
}

/**
 * Calculates cosine similarity between two vectors
 * @param {Array} vecA - First vector
 * @param {Array} vecB - Second vector
 * @returns {number} - Cosine similarity (between -1 and 1)
 */
function calculateCosineSimilarity(vecA, vecB) {
  if (!vecA || !vecB || vecA.length !== vecB.length) {
    return 0;
  }
  
  let dotProduct = 0;
  let normA = 0;
  let normB = 0;
  
  for (let i = 0; i < vecA.length; i++) {
    dotProduct += vecA[i] * vecB[i];
    normA += vecA[i] * vecA[i];
    normB += vecB[i] * vecB[i];
  }
  
  normA = Math.sqrt(normA);
  normB = Math.sqrt(normB);
  
  if (normA === 0 || normB === 0) {
    return 0;
  }
  
  return dotProduct / (normA * normB);
}

/**
 * Tags a chat entry as a "Moment" with a custom label and timestamp
 * @param {string} userId - The user ID
 * @param {string} chatId - The chat entry ID
 * @param {Object} momentData - The moment data (label and timestamp)
 * @returns {Promise<Object|null>} - The updated chat entry or null if not found
 */
async function tagChatEntryAsMoment(userId, chatId, momentData) {
  try {
    // Get the chat entry directly from the chatHistory collection
    const chatEntryRef = db.collection('chatHistory').doc(chatId);
    const chatEntryDoc = await chatEntryRef.get();
    
    if (!chatEntryDoc.exists) {
      console.log(`Chat entry with ID ${chatId} not found`);
      return null;
    }
    
    // Get the chat entry data
    const chatEntry = chatEntryDoc.data();
    
    // Verify this chat entry belongs to the specified user
    if (chatEntry.userId !== userId) {
      console.log(`Chat entry with ID ${chatId} does not belong to user ${userId}`);
      return null;
    }
    
    // Store moment data as a single object
    const updatedMomentData = {
      moment: true,
      label: momentData.label || '',
      timestamp: momentData.timestamp || new Date().toISOString()
    };
    
    // Update the document with the moment data
    await chatEntryRef.update({
      momentData: updatedMomentData,
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });
    
    // Return the updated chat entry
    return {
      ...chatEntry,
      momentData: updatedMomentData,
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    };
  } catch (error) {
    console.error('Error tagging chat entry as moment:', error);
    throw new Error('Failed to tag chat entry as moment: ' + error.message);
  }
}

/**
 * Gets all moments for a specific user
 * @param {string} userId - The user ID
 * @param {string} label - Optional label to filter moments by
 * @returns {Promise<Array>} - Array of moment chat entries
 */
async function getMomentsForUser(userId, label = null) {
  try {
    // Get the user document to retrieve their chat IDs
    const userRef = db.collection('users').doc(userId);
    const userDoc = await userRef.get();
    
    if (!userDoc.exists || !userDoc.data().chatIds || userDoc.data().chatIds.length === 0) {
      console.log(`No chat entries found for user ${userId}`);
      return [];
    }
    
    // Get all chat entries for the user
    const chatIds = userDoc.data().chatIds;
    const chatEntries = [];
    
    // Query all chat entries from the chatHistory collection
    const chatHistoryRef = db.collection('chatHistory');
    const chatSnapshot = await chatHistoryRef.where('userId', '==', userId).get();
    
    if (chatSnapshot.empty) {
      console.log(`No chat entries found for user ${userId} in chatHistory collection`);
      return [];
    }
    
    // Process each chat entry
    chatSnapshot.forEach(doc => {
      const chatEntry = doc.data();
      if (chatEntry.momentData && chatEntry.momentData.moment === true) {
        chatEntries.push(chatEntry);
      }
    });
    
    // Filter moments by label if provided
    let moments = chatEntries;
    if (label) {
      moments = moments.filter(entry => 
        entry.momentData && entry.momentData.label && 
        entry.momentData.label.toLowerCase().includes(label.toLowerCase())
      );
    }
    
    // Sort by timestamp in momentData (newest first)
    return moments.sort((a, b) => {
      const timeA = a.momentData && a.momentData.timestamp ? new Date(a.momentData.timestamp) : new Date(a.timestamp);
      const timeB = b.momentData && b.momentData.timestamp ? new Date(b.momentData.timestamp) : new Date(b.timestamp);
      return timeB - timeA;
    });
  } catch (error) {
    console.error('Error retrieving moments:', error);
    throw new Error('Failed to retrieve moments: ' + error.message);
  }
}

/**
 * Migrates existing moments to use the new momentData format
 * @param {string} userId - The user ID
 * @returns {Promise<number>} - Number of migrated entries
 */
async function migrateMomentsToNewFormat(userId) {
  try {
    // Get the user document to retrieve their chat IDs
    const userRef = db.collection('users').doc(userId);
    const userDoc = await userRef.get();
    
    if (!userDoc.exists || !userDoc.data().chatIds || userDoc.data().chatIds.length === 0) {
      console.log(`No chat entries found for user ${userId}`);
      return 0;
    }
    
    // Query all chat entries from the chatHistory collection for this user
    const chatHistoryRef = db.collection('chatHistory');
    const chatSnapshot = await chatHistoryRef.where('userId', '==', userId).get();
    
    if (chatSnapshot.empty) {
      console.log(`No chat entries found for user ${userId} in chatHistory collection`);
      return 0;
    }
    
    let migratedCount = 0;
    const batch = db.batch();
    
    // Process each chat entry
    chatSnapshot.forEach(doc => {
      const chatEntry = doc.data();
      const docRef = chatHistoryRef.doc(doc.id);
      
      // Find entries that use the old format (have moment property but no momentData)
      if (chatEntry.moment === true && !chatEntry.momentData) {
        // Create momentData object from individual properties
        const updatedMomentData = {
          moment: true,
          label: chatEntry.momentLabel || '',
          timestamp: chatEntry.momentTimestamp || chatEntry.timestamp
        };
        
        // Update the document with the new momentData and remove old properties
        batch.update(docRef, {
          momentData: updatedMomentData,
          moment: admin.firestore.FieldValue.delete(),
          momentLabel: admin.firestore.FieldValue.delete(),
          momentTimestamp: admin.firestore.FieldValue.delete(),
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        
        migratedCount++;
      }
    });
    
    // Only commit the batch if we made changes
    if (migratedCount > 0) {
      await batch.commit();
      console.log(`Migrated ${migratedCount} chat entries to new moment format`);
    }
    
    return migratedCount;
  } catch (error) {
    console.error('Error migrating moments to new format:', error);
    throw new Error('Failed to migrate moments: ' + error.message);
  }
}

/**
 * Updates user behavior tracking data based on app usage patterns
 * @param {string} userId - The user ID
 * @param {Date} currentOpenTime - The current time when the app was opened (defaults to now)
 * @returns {Promise<Object>} - The updated usage tracking data
 */
async function updateUserBehaviorTracking(userId, currentOpenTime = new Date()) {
  try {
    const userRef = db.collection('users').doc(userId);
    const userDoc = await userRef.get();
    
    // Default usage tracking structure
    let usageTracking = {
      late_night: false,
      burst_usage: false,
      session_gap: "0 days",
      last_open: currentOpenTime.toISOString(),
      open_duration_minutes: 0, // Will be calculated based on real data
      usage_history: [] // Array to store historical usage data
    };
    
    // If document exists, get current tracking data or initialize
    if (userDoc.exists) {
      const userData = userDoc.data();
      
      // Use existing tracking data if available, otherwise use default
      if (userData.usageTracking) {
        usageTracking = { ...usageTracking, ...userData.usageTracking };
      }
      
      // Check if usage_history exists, if not initialize it
      if (!usageTracking.usage_history) {
        usageTracking.usage_history = [];
      }
      
      // Calculate session gap if last_open exists
      if (usageTracking.last_open) {
        const lastOpenDate = new Date(usageTracking.last_open);
        const diffTime = Math.abs(currentOpenTime - lastOpenDate);
        const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
        usageTracking.session_gap = `${diffDays} days`;
      }
      
      // Detect late-night usage (between 12:00 AM and 5:00 AM local time)
      const hours = currentOpenTime.getHours();
      usageTracking.late_night = (hours >= 0 && hours < 5);
      
      // Detect burst usage (more than 3 opens within 1 hour)
      const oneHourAgo = new Date(currentOpenTime.getTime() - (60 * 60 * 1000));
      const recentOpens = usageTracking.usage_history.filter(entry => {
        const entryTime = new Date(entry.open_time);
        return entryTime >= oneHourAgo && entryTime <= currentOpenTime;
      });
      
      usageTracking.burst_usage = (recentOpens.length >= 3);
      
      // Update last_open time
      usageTracking.last_open = currentOpenTime.toISOString();
      
      // Calculate open_duration_minutes based on real data
      // If there are previous sessions, calculate the average duration
      if (usageTracking.usage_history.length > 0) {
        // Get the last 5 sessions or all if less than 5
        const recentSessions = usageTracking.usage_history.slice(-5);
        let totalDuration = 0;
        let sessionCount = 0;
        
        // Calculate the average duration of recent sessions
        for (let i = 0; i < recentSessions.length; i++) {
          if (recentSessions[i].duration_minutes) {
            totalDuration += recentSessions[i].duration_minutes;
            sessionCount++;
          }
        }
        
        // If we have previous session durations, use their average
        if (sessionCount > 0) {
          usageTracking.open_duration_minutes = Math.round(totalDuration / sessionCount);
        } else {
          // Default to 10 minutes if no previous data
          usageTracking.open_duration_minutes = 10;
        }
      } else {
        // Default to 10 minutes for first-time users
        usageTracking.open_duration_minutes = 10;
      }
      
      // Add current session to usage history
      usageTracking.usage_history.push({
        open_time: currentOpenTime.toISOString(),
        late_night: usageTracking.late_night,
        session_gap: usageTracking.session_gap,
        duration_minutes: usageTracking.open_duration_minutes // Store the calculated duration
      });
      
      // Limit history to last 50 entries
      if (usageTracking.usage_history.length > 50) {
        usageTracking.usage_history = usageTracking.usage_history.slice(-50);
      }
      
      // Update the document with new tracking data
      await userRef.update({
        usageTracking: usageTracking,
        updatedAt: admin.firestore.FieldValue.serverTimestamp()
      });
    } else {
      // If document doesn't exist, create it with initial tracking data
      await userRef.set({
        user_id: userId,
        chatIds: [],
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        usageTracking: {
          ...usageTracking,
          usage_history: [{
            open_time: currentOpenTime.toISOString(),
            late_night: usageTracking.late_night,
            session_gap: "0 days"
          }]
        }
      });
    }
    
    return usageTracking;
  } catch (error) {
    console.error('Error updating user behavior tracking:', error);
    throw new Error('Failed to update user behavior tracking: ' + error.message);
  }
}

/**
 * Gets the current user behavior tracking data
 * @param {string} userId - The user ID
 * @returns {Promise<Object>} - The current usage tracking data
 */
async function getUserBehaviorTracking(userId) {
  try {
    const userRef = db.collection('users').doc(userId);
    const userDoc = await userRef.get();
    
    if (!userDoc.exists || !userDoc.data().usageTracking) {
      // Return default structure if no tracking data exists
      return {
        late_night: false,
        burst_usage: false,
        session_gap: "0 days",
        last_open: new Date().toISOString(),
        open_duration_minutes: 10, // Default for new users
        usage_history: []
      };
    }
    
    const usageTracking = userDoc.data().usageTracking;
    
    // Ensure open_duration_minutes is calculated based on real data
    if (usageTracking.usage_history && usageTracking.usage_history.length > 0) {
      // Get the last 5 sessions or all if less than 5
      const recentSessions = usageTracking.usage_history.slice(-5);
      let totalDuration = 0;
      let sessionCount = 0;
      
      // Calculate the average duration of recent sessions
      for (let i = 0; i < recentSessions.length; i++) {
        if (recentSessions[i].duration_minutes) {
          totalDuration += recentSessions[i].duration_minutes;
          sessionCount++;
        }
      }
      
      // If we have previous session durations, use their average
      if (sessionCount > 0) {
        usageTracking.open_duration_minutes = Math.round(totalDuration / sessionCount);
      } else if (!usageTracking.open_duration_minutes) {
        // Default to 10 minutes if no previous data and no existing value
        usageTracking.open_duration_minutes = 10;
      }
    } else if (!usageTracking.open_duration_minutes) {
      // Default to 10 minutes for first-time users with no history
      usageTracking.open_duration_minutes = 10;
    }
    
    return usageTracking;
  } catch (error) {
    console.error('Error retrieving user behavior tracking:', error);
    throw new Error('Failed to retrieve user behavior tracking: ' + error.message);
  }
}

/**
 * Extracts user preferences from chat messages using OpenAI
 * @param {string} userId - The user ID
 * @param {string} message - The user's message to analyze
 * @returns {Promise<Object>} - The updated user preferences
 */
async function extractUserPreferences(userId, message) {
  try {

    // Get existing preferences or initialize
    const userRef = db.collection('users').doc(userId);
    const userDoc = await userRef.get();
    
    let preferences = {};
    
    if (userDoc.exists && userDoc.data().preferences) {
      preferences = userDoc.data().preferences;
    } else {
      // Initialize preferences structure if it doesn't exist
      preferences = {
        lastUpdated: new Date().toISOString()
      };
    }

    // Get recent chat history for context
    const chatHistory = await getChatHistoryForUser(userId, 5);
    let chatContext = "";
    
    if (chatHistory && chatHistory.length > 0) {
      chatContext = "Recent conversation history:\n";
      chatHistory.forEach(entry => {
        chatContext += `User: ${entry.question}\nAssistant: ${entry.response}\n\n`;
      });
    }

    // Prepare the prompt for OpenAI
    const prompt = `You are an AI assistant that extracts user preferences from conversations. 
    Analyze the following message and extract any preferences the user mentions.
    
    Current message: "${message}"
    
    ${chatContext ? chatContext : ""}
    
    Extract preferences in the following categories and any new categories you discover:
    - foods (likes, dislikes, allergies)
    - places (frequented locations, favorite spots)
    - brands (clothing, electronics, etc.)
    - activities (hobbies, interests)
    - entertainment (movies, music, books)
    - schedule (routines, preferred times)
    
    If you find preferences in a category not listed above, create a new category for it.
    
    Format your response as a JSON object with arrays for each category. Only include categories where you found preferences.
    Example format:
    {
      "foods": {
        "likes": ["pizza", "sushi"],
        "dislikes": ["broccoli"],
        "allergies": ["peanuts"]
      },
      "places": ["coffee shop on 5th street", "central park"],
      "new_category_name": ["preference1", "preference2"]
    }
    
    IMPORTANT: Only respond with the raw JSON object. Do not include any markdown formatting, code blocks, or backticks in your response. Do not include any explanatory text before or after the JSON.`;

    try {
      // Call OpenAI to extract preferences
      const completion = await openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [{
          role: 'user',
          content: prompt
        }],
        temperature: 0.3,
        max_tokens: 500
      });
      
      // Check if the response contains concerning content
      const responseContent = completion.choices[0].message.content.trim();
      if (responseContent.includes('die') || 
          responseContent.includes('suicide') || 
          responseContent.includes('kill') || 
          !responseContent.includes('{')) {
        console.log('Potentially concerning or invalid response from OpenAI:', responseContent);
        return preferences; // Return existing preferences without updating
      }

      let extractedPreferencesText = responseContent;
      let extractedPreferences;
      
      try {
        // Remove markdown code block delimiters if present
        if (extractedPreferencesText.startsWith('```json')) {
          extractedPreferencesText = extractedPreferencesText.replace(/^```json\s*/, '').replace(/\s*```$/, '');
        } else if (extractedPreferencesText.startsWith('```')) {
          extractedPreferencesText = extractedPreferencesText.replace(/^```\s*/, '').replace(/\s*```$/, '');
        }
        
        // Parse the JSON response
        extractedPreferences = JSON.parse(extractedPreferencesText);
      } catch (parseError) {
        console.error('Error parsing OpenAI response:', parseError);
        console.log('Raw response:', extractedPreferencesText);
        return preferences; // Return existing preferences if parsing fails
      }

      // Merge extracted preferences with existing preferences
      for (const category in extractedPreferences) {
        if (category === 'foods') {
          // Special handling for foods category with subcategories
          if (!preferences.foods) {
            preferences.foods = {
              likes: [],
              dislikes: [],
              allergies: []
            };
          }
          
          // Merge food subcategories
          for (const subCategory in extractedPreferences.foods) {
            if (!preferences.foods[subCategory]) {
              preferences.foods[subCategory] = [];
            }
            
            // Add new items avoiding duplicates
            extractedPreferences.foods[subCategory].forEach(item => {
              if (!preferences.foods[subCategory].includes(item)) {
                preferences.foods[subCategory].push(item);
              }
            });
          }
        } else {
          // Handle other categories
          if (!preferences[category]) {
            preferences[category] = [];
          }
          
          // If the category is an array
          if (Array.isArray(extractedPreferences[category])) {
            // Add new items avoiding duplicates
            extractedPreferences[category].forEach(item => {
              if (!preferences[category].includes(item)) {
                preferences[category].push(item);
              }
            });
          } else if (typeof extractedPreferences[category] === 'object') {
            // If the category is an object with subcategories
            if (!preferences[category] || typeof preferences[category] !== 'object') {
              preferences[category] = {};
            }
            
            // Merge subcategories
            for (const subCategory in extractedPreferences[category]) {
              if (!preferences[category][subCategory]) {
                preferences[category][subCategory] = [];
              }
              
              // Add new items avoiding duplicates
              extractedPreferences[category][subCategory].forEach(item => {
                if (!preferences[category][subCategory].includes(item)) {
                  preferences[category][subCategory].push(item);
                }
              });
            }
          }
        }
      }

      // Update lastUpdated timestamp
      preferences.lastUpdated = new Date().toISOString();

      // Save updated preferences to Firestore
      await userRef.update({
        preferences: preferences,
        updatedAt: admin.firestore.FieldValue.serverTimestamp()
      });

      return preferences;
    } catch (error) {
      console.error('Error extracting user preferences:', error);
      throw new Error('Failed to extract user preferences: ' + error.message);
    }
  } catch (error) {
    console.error('Error extracting user preferences:', error);
    throw new Error('Failed to extract user preferences: ' + error.message);
  }
}

/**
 * Gets the user preferences
 * @param {string} userId - The user ID
 * @returns {Promise<Object>} - The user preferences
 */
async function getUserPreferences(userId) {
  try {
    const userRef = db.collection('users').doc(userId);
    const userDoc = await userRef.get();
    
    if (!userDoc.exists || !userDoc.data().preferences) {
      // Return default structure if no preferences exist
      return {
        foods: {
          likes: [],
          dislikes: [],
          allergies: []
        },
        places: [],
        brands: [],
        activities: [],
        entertainment: [],
        schedule: [],
        lastUpdated: new Date().toISOString()
      };
    }
    
    return userDoc.data().preferences;
  } catch (error) {
    console.error('Error retrieving user preferences:', error);
    throw new Error('Failed to retrieve user preferences: ' + error.message);
  }
}

module.exports = { 
  generateResponse, 
  getChatHistoryForUser, 
  clearChatHistoryForUser,
  getChatEntryById,
  generateEmbeddings,
  addEmbeddingsToChatEntry,
  semanticSearch,
  tagChatEntryAsMoment,
  getMomentsForUser,
  migrateMomentsToNewFormat,
  updateUserBehaviorTracking,
  getUserBehaviorTracking,
  extractUserPreferences,
  getUserPreferences,
  generateChatSummary
};
